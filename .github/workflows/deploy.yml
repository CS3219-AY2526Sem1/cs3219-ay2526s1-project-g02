name: Build and Deploy to GKE

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'

  workflow_dispatch:

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: noclue-cluster
  GKE_ZONE: us-central1-a
  NAMESPACE: noclue-app

jobs:
  deploy:
    name: Build, Push, and Deploy
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build common package
      run: npm run build:common

    - name: Run tests
      run: npm run test --if-present

    # Authenticate with Google Cloud
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Configure Docker for GCR
      run: gcloud auth configure-docker

    # Build and push Docker images (backend services first)
    - name: Build and Push User Service
      run: |
        docker build -f Dockerfile.user-service \
          -t gcr.io/$GCP_PROJECT_ID/user-service:$GITHUB_SHA \
          -t gcr.io/$GCP_PROJECT_ID/user-service:latest .
        docker push gcr.io/$GCP_PROJECT_ID/user-service:$GITHUB_SHA
        docker push gcr.io/$GCP_PROJECT_ID/user-service:latest

    - name: Build and Push Question Service
      run: |
        docker build -f Dockerfile.question-service \
          -t gcr.io/$GCP_PROJECT_ID/question-service:$GITHUB_SHA \
          -t gcr.io/$GCP_PROJECT_ID/question-service:latest .
        docker push gcr.io/$GCP_PROJECT_ID/question-service:$GITHUB_SHA
        docker push gcr.io/$GCP_PROJECT_ID/question-service:latest

    - name: Build and Push Matching Service
      run: |
        docker build -f Dockerfile.matching-service \
          -t gcr.io/$GCP_PROJECT_ID/matching-service:$GITHUB_SHA \
          -t gcr.io/$GCP_PROJECT_ID/matching-service:latest .
        docker push gcr.io/$GCP_PROJECT_ID/matching-service:$GITHUB_SHA
        docker push gcr.io/$GCP_PROJECT_ID/matching-service:latest

    - name: Build and Push Collaboration Service
      run: |
        docker build -f Dockerfile.collaboration-service \
          -t gcr.io/$GCP_PROJECT_ID/collaboration-service:$GITHUB_SHA \
          -t gcr.io/$GCP_PROJECT_ID/collaboration-service:latest .
        docker push gcr.io/$GCP_PROJECT_ID/collaboration-service:$GITHUB_SHA
        docker push gcr.io/$GCP_PROJECT_ID/collaboration-service:latest

    - name: Build and Push LLM Service
      run: |
        docker build -f Dockerfile.llm-service \
          -t gcr.io/$GCP_PROJECT_ID/llm-service:$GITHUB_SHA \
          -t gcr.io/$GCP_PROJECT_ID/llm-service:latest .
        docker push gcr.io/$GCP_PROJECT_ID/llm-service:$GITHUB_SHA
        docker push gcr.io/$GCP_PROJECT_ID/llm-service:latest

    # Get GKE credentials
    - name: Get GKE credentials
      run: |
        gcloud container clusters get-credentials $GKE_CLUSTER \
          --zone $GKE_ZONE \
          --project $GCP_PROJECT_ID

    # Install kubectl auth plugin
    - name: Install gke-gcloud-auth-plugin
      run: |
        gcloud components install gke-gcloud-auth-plugin

    # Setup cluster (idempotent - safe to run every time)
    - name: Setup GKE Cluster
      run: |
        chmod +x ./scripts/setup-gke.sh
        ./scripts/setup-gke.sh

    # Setup Pub/Sub authentication and topics
    - name: Setup Pub/Sub Secrets in Kubernetes
      run: |
        # Create the secret from GitHub Secrets (key was created manually)
        echo '${{ secrets.GCP_PUBSUB_KEY }}' > pubsub-service-key.json
        
        # Create Kubernetes secret
        kubectl create secret generic pubsub-key \
          --from-file=key.json=pubsub-service-key.json \
          -n ${{ env.NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Create ConfigMap
        kubectl create configmap pubsub-config \
          --from-literal=GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }} \
          -n ${{ env.NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Clean up the key file
        rm -f pubsub-service-key.json
        
        echo "✅ Pub/Sub credentials configured in Kubernetes"
      env:
        GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

    - name: Setup Pub/Sub Topics and Subscriptions
      run: |
        npm install -g tsx
        npx tsx scripts/setup-pubsub.ts
      env:
        GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

    # Create frontend URL ConfigMap
    - name: Create Frontend URL ConfigMap
      run: |
        # Use custom domain if set, otherwise will be updated after getting LoadBalancer IP
        SITE_URL="${{ secrets.SITE_URL }}"
        if [[ -z "$SITE_URL" ]]; then
          SITE_URL="http://localhost:3000"  # Placeholder, will be updated later
        fi
        
        kubectl create configmap frontend-url-config \
          --from-literal=FRONTEND_URL="$SITE_URL" \
          -n ${{ env.NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        echo "✅ Frontend URL ConfigMap created with: $SITE_URL"

    # Deploy services with secrets from GitHub Secrets
    - name: Deploy Services
      env:
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
        SUPABASE_PUBLISHABLE_KEY: ${{ secrets.SUPABASE_PUBLISHABLE_KEY }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        chmod +x ./scripts/deploy-services.sh
        ./scripts/deploy-services.sh

    # Wait for backend LoadBalancer IPs to be assigned
    - name: Wait for LoadBalancer IPs
      run: |
        echo "⏳ Waiting for LoadBalancer IPs to be assigned..."
        sleep 60
        
        # Get backend service IPs
        USER_IP=$(kubectl get service user-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        QUESTION_IP=$(kubectl get service question-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        MATCHING_IP=$(kubectl get service matching-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        COLLAB_IP=$(kubectl get service collaboration-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        LLM_IP=$(kubectl get service llm-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        echo "Backend LoadBalancer IPs:"
        echo "  User: $USER_IP"
        echo "  Question: $QUESTION_IP"
        echo "  Matching: $MATCHING_IP"
        echo "  Collaboration: $COLLAB_IP"
        echo "  LLM: $LLM_IP"
        
        # Export for next steps
        echo "USER_SERVICE_IP=$USER_IP" >> $GITHUB_ENV
        echo "QUESTION_SERVICE_IP=$QUESTION_IP" >> $GITHUB_ENV
        echo "MATCHING_SERVICE_IP=$MATCHING_IP" >> $GITHUB_ENV
        echo "COLLABORATION_SERVICE_IP=$COLLAB_IP" >> $GITHUB_ENV
        echo "LLM_SERVICE_IP=$LLM_IP" >> $GITHUB_ENV

    # Get frontend LoadBalancer IP for SITE_URL
    - name: Get Frontend LoadBalancer IP
      run: |
        FRONTEND_IP=$(kubectl get service frontend-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "")
        if [[ -z "$FRONTEND_IP" ]]; then
          echo "⚠️ Frontend IP not yet assigned, using placeholder"
          FRONTEND_IP="PENDING"
        fi
        echo "FRONTEND_IP=$FRONTEND_IP" >> $GITHUB_ENV
        echo "Frontend IP: $FRONTEND_IP"

    # Build and push frontend with backend URLs
    - name: Build and Push Frontend
      run: |
        # Determine site URL - use custom domain if set, otherwise use LoadBalancer IP
        SITE_URL="${{ secrets.SITE_URL }}"
        if [[ -z "$SITE_URL" ]]; then
          if [[ "$FRONTEND_IP" != "PENDING" ]]; then
            SITE_URL="http://$FRONTEND_IP"
          else
            SITE_URL="http://localhost:3000"
          fi
        fi
        
        echo "Building frontend with SITE_URL: $SITE_URL"
        
        docker build -f Dockerfile.frontend \
          --build-arg NEXT_PUBLIC_USER_GRAPHQL_URL="http://$USER_SERVICE_IP:4001/graphql" \
          --build-arg NEXT_PUBLIC_QUESTION_GRAPHQL_URL="http://$QUESTION_SERVICE_IP:4002/graphql" \
          --build-arg NEXT_PUBLIC_MATCHING_GRAPHQL_URL="http://$MATCHING_SERVICE_IP:4003/graphql" \
          --build-arg NEXT_PUBLIC_COLLABORATION_GRAPHQL_URL="http://$COLLABORATION_SERVICE_IP:4004/graphql" \
          --build-arg NEXT_PUBLIC_LLM_SERVICE_URL="http://$LLM_SERVICE_IP:4005" \
          --build-arg NEXT_PUBLIC_MATCHING_SERVICE_URL="http://$MATCHING_SERVICE_IP:4003" \
          --build-arg NEXT_PUBLIC_GRAPHQL_URL="http://$USER_SERVICE_IP:4001/graphql" \
          --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ secrets.SUPABASE_URL }}" \
          --build-arg NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY="${{ secrets.SUPABASE_PUBLISHABLE_KEY }}" \
          --build-arg NEXT_PUBLIC_SITE_URL="$SITE_URL" \
          -t gcr.io/$GCP_PROJECT_ID/frontend:$GITHUB_SHA \
          -t gcr.io/$GCP_PROJECT_ID/frontend:latest .
        docker push gcr.io/$GCP_PROJECT_ID/frontend:$GITHUB_SHA
        docker push gcr.io/$GCP_PROJECT_ID/frontend:latest

    # Deploy frontend with new image
    - name: Deploy Frontend
      run: |
        kubectl rollout restart deployment/frontend -n $NAMESPACE
        kubectl rollout status deployment/frontend -n $NAMESPACE --timeout=300s

    # Update Frontend URL ConfigMap with actual LoadBalancer IP
    - name: Update Frontend URL ConfigMap
      run: |
        # Use custom domain if set, otherwise use the LoadBalancer IP
        SITE_URL="${{ secrets.SITE_URL }}"
        if [[ -z "$SITE_URL" ]]; then
          if [[ "$FRONTEND_IP" != "PENDING" ]]; then
            SITE_URL="http://$FRONTEND_IP"
          else
            echo "⚠️ Frontend IP still pending, skipping ConfigMap update"
            exit 0
          fi
        fi
        
        echo "Updating Frontend URL ConfigMap to: $SITE_URL"
        
        kubectl create configmap frontend-url-config \
          --from-literal=FRONTEND_URL="$SITE_URL" \
          -n ${{ env.NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Restart user-service to pick up the new ConfigMap value
        kubectl rollout restart deployment/user-service -n ${{ env.NAMESPACE }}
        
        echo "✅ Frontend URL ConfigMap updated and user-service restarted"

    # Get service URLs
    - name: Get Service URLs
      run: |
        echo "=== Service URLs ==="
        echo ""
        echo "Frontend (LoadBalancer):"
        kubectl get service frontend-service -n $NAMESPACE \
          -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "Pending..."
        echo ""
        echo ""
        echo "Backend Services (ClusterIP - internal only):"
        kubectl get services -n $NAMESPACE -l service=backend || true
        echo ""
        echo "=== Deployment Complete ==="
